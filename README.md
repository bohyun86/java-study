# Java 기초 프로그래밍
1. 자바 설치 및 IDE 설치와 사용
- 프로그래밍이란?
- 주석, 실행문
- JDK, JRE, JVM
2. 변수
- 변수 선언, 변수 초기화 (Initialize)
- 변수 사용, 변수 사용범위 (Scope)
3. 타입
- 정수 타입: int, long
- 실수 타입: double
- 논리 타입: boolean
4. 타입 변환
- 자동 타입변환(Promotion): 작은 범위 -> 큰 범위
- 강제 타입 변환(Casting): 큰 범위 -> 작은 범위 (캐스팅연산자)
5. 연산자
- 단항 연산자, 이항 연산자, 상항 연산자
- 산술 연산자, 대입 연산자, 증감 연산자 등
- 연산자 우선순위가 존재
6. 조건문
- if
- if-else, if-else-if
- switch-case
7. 반복문
- while
- for
- do-while
- break, continue
8. 배열
- 배열 선언, 배열 초기화, 배열 길이
- 다차원 배열
- 향상된 for문 
9. 매서드
- 매서드 선언, 메서드 호출,
- 리턴값, 리턴 타입
- 매개변수(parameter), 인자(argument)
- 매서드 오버로딩(overloading)
10. 클래스
- 



## 메서드 정의
- 제어자(Modifier): public, static
- 리턴타입(Return Type): 메서드가 실행된 뒤 반환되는 타입
- 메서드이름(Method Name): 메서드를 호출하는데 사용됨. 기능이 드러나도록 이름을 짓는 것이 좋다
- 매개변수(Parameter): 입력 값, 메서드 내부에서 사용 가능한 변수, 매개변수가 없을 수도 있음
- 메서드 본문(Method Body): 실행되는 코드 블록, {} 사이 위치

## 메서드의 종류
- 매개변수가 없고 리턴타입도 없는 메서드 정의
- 리턴 타입이 없는 경우 void를 사용

## 매서드의 장점
- 반복되는 코드의 중복을 줄일 수 있다.
- 작업이 분리되어 코드의 가독성이 향상된다.
- 코드를 다른 프로그램에서 재사용할 수 있다.
- 기존의 기능을 확장해서 사용하는데 유용하다.
- 메서드를 사용할 때는 내부 작업, 구현부에 대해 알 필요가 없이 사용할 수 있다.
- 모듈화된 메서드는 개별적으로 테스트하고 디버깅 할 수 있다.
- 유지보수가 용이해진다.

## 메서드 명명 규칙
1. 기보적으로 변수 이름 붙이는 방식과 같다. (CamelCase 등)
2. 메서드의 이름에는 동사를 사용해서 시작하는 것이 좋다.
- addNumbers: 두 숫자를 더하는 메서드 <- 명시적으로 추측 가능
- getStudentInfo: 학생의 정보를 가져오는 메서드
- setEmployeeName: 직원의 이름을 설정하는 메서드
3. 일반적으로 널리 사용되지 않는 약어는 사용하지 않는 것이 좋다.
- addN, getSi, setEn <- 무슨 동작을 하는 메서드인지 추측하기 어렵다.

## 객체지향 프로그래밍
1. 절차적 프로그래밍 (Procedural Programming)
- 프로그램을 일련의 순서, 절차나, 함수의 집합으로 보는 방식
- 상단에서부터 하단으로 프로그램 코드를 순서대로 실행
- 함수(Function)/절차(Procedure)를 정의하고 호출
2. 객체지향 프로그래밍(OOP: Object-Oriented Programming)
- 프로그램을 객체의 집합으로 보는 방식
- 객체는 데이터(속성, 필드)와 데이터를 조작하는 기능(함수, 메서드)으로 캡슐화됨.
- 주요 4대 특징
- 캡슐화: 데이터와 기능을 캡슐처럼 함께 포장
- 상속: 한 클래스가 다른 클래스의 특성을 상속받음
- 다형성: 객체 타입에 따라 다른 방식으로 작동
- 추상화: 복잡한 실제 세계를 단순한 모델로 표현
3. 모든 사물과 개념을 속성과 기능을 가지고 있는 객체로 단순화, 추상화 시키는 것
4. 객체 지향 프로그래밍 방법이 가장 널리 사용되고 있다.


## 클래스
1. 객체를 생성하기 위한 설계도 혹은 틀 , 템플릿
2. 클래스의 구조
- Field: 객체의 데이터
- Constructor: 객체를 생성할 때 초기화를 담당
- Method: 객체가 수행하는 행동
3. 생성자

@ 특징 @
- 클래스 이름과 동일
- 리턴 타입이 없음(void도 사용하지 않음)
- 오버로딩이 가능 (매개변수의 타입이나 개수에 따라 여러개 정의 가능)

@ 종류 @
- 기본생성자: 사용자가 정의하지 않으면 컴파일러에서 자동 생성 (매개변수 없음)
- 사용자 정의 생성자: 매개변수를 가지고, 객체 생성시 초기값을 전달

@ this 키워드 @
- 객체가 자기 자신을 가리키는데 사용되는 키워드
- 생성자에서 매개변수와 클래스으 ㅣ필드 이름이 중복되는 경우가 있을 때
- this 키워드를 통해 둘을 구분: 'this.name = name'
- this(): 다른 생성자를 호출할 때
- 생성자 오버로딩이 있을 때 코드의 중복을 줄일 수 있음


## 객체
1. 클래스(설계도)에서 정의된대로 메모리에 할당되는 인스턴스(Instance: 실례, 사례)
2. new 키워드를 통해서 객체를 생성

### 객체(Object)와 인스턴스(Instance)의 차이
- 클래스에서 나온 실체. 인스턴스는 클래스의 관계에 맞춰져있음.
- Student는 클래스다.
- student1은 Student의 인스턴스다.
- student1은 객체다.

## 패키지
1. 패키지 생성 규칙 및 관례
1) 패키지는 전세계에서 유일하게 만드는 것이 좋다.
- 일반적으로 인터넷 도메인 이름을 역순으로 사용한다. ('com.google.project.pack.abc', 'com.naver.cafe.member')
- 패키지 이름에는 모두 소문자만 사용한다.
- '.'을 사용해서 계층 구조를 만든다.
- 예약어를 사용할 수가 없다. 'class', 'enum', 'package' 사용불가
- 숫자로 시작할 수 없다.

 - 'package0' 상위패키지
  - 'package.first' 하위패키지
  - 'package.second' 
- 세 패키지는 계층 구조를 이루지만, 각각의 패키지는 서로 다른 패키지이다.

## 접근제한자 Access Modifier
1. public
- 어떤 클래스에서도 접근 가능
- 사용자에게 접근을 열어두고 싶은 경우
2. protected
- 상속 관계에서 부모 클래스가 자식 클래스에서 접근 가능할 때 사용
- 다른 패키지에 있을 경우에도
3. default (package-private)
- 접근 제한자를 명시하지 않은 경우
- 같은 패키지 내부에서만 접근, 사용이 가능하다.
4. private
- 해당 멤버를 선언한 클래스에서만 접근 가능
- 사용자에게 접근을 차단하고 싶은 경우, 내부 구현을 숨기고 싶은 경우

## Getter, Setter 메소드
1. 객체지향 프로그래밍에서는 일바적으로 객체의 필드값에 외부 직접 접근을 막는다. (private)
2. 사용자가 개발자의 의도에 맞게 변경하거나 값을 가지고 올 수 있도록 별도의 메서드를 만든다. 
3. 데이터의 무결성을 유지할 수 있음
4. 캡슐화 원칙을 실현하고, 데이터를 보호할 수 있음
- Getter: 필드의 값을 안전하게(제약조건, 무결성 유지하여) 읽기 'getSpeed'
- Setter: 필드의 값을 안전하게(제약조건, 무결성 유지하며) 설정 'setSpeed'

:+1:
